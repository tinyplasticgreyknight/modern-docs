Mutation
========

Although many functional languages are additionally "purely functional", meaning that their variables are immutable, nodes can be mutated in memory in some languages. This is to make it easier to create cyclic structures, which could not otherwise be done in languages without recursive binding. The semantics of mutation are that all references to the old node become references to the new node. Mutation is possible on all nodes, with the provision that nodes being modified have never been in scope in any context. In other words, once a node has become part of a schema of types and and thus potentially has extant nodes which are values of it, it can no longer be modified. This is, of course, to avoid the scenario of a value node being inconsistent in structure with the type node that corresponds to it. Naturally, it is always possible to construct a copy of a node and modify the copy.

Of course, it is expected that sets of types for some particular purpose will be constructed in most situations not through imperative code but through the use of an interactive editor having Modern Data as its native format. The ease with which what would be called a schema in other systems can be serialized and deserialized obviates the need to construct one by hand, most of the time. As such, the details discussed above should seldom be an issue.
